---
title: "Data Wrangling ddd hhh"
author: 
  - "Martin Arnold"
  - "Alexander Gerber"
date: '`r Sys.Date()`'
output:
  xaringan::moon_reader:
    lib_dir: libs
    css:  ["../xaringan_files/xaringan-themer.css", "../xaringan_files/custom.css"]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
     #ratio: "16:9"
    #includes:
     # after_body: ../xaringan_files/terminal_highlight.html
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
```

```{r, include=FALSE}
library(microbenchmark)
```

---
class: top, left
### Tibble
- Tibbles are the main data structure used in the tidyverse and can be viewed as a modern version of the `data.frame`. 

- `tibble()` creates a new tibble from scatch

- `as_tibble()` creates a tibble from an existing object (e.g. a `data.frame`)

- Why should we use tibbles instead of `data.frame`s? See the following comparison.  

---
class: top, left

### Tibble vs. data.frame

```{r, echo = TRUE}
library(tidyverse)
data(mtcars) 
mtcars_tibble <- as_tibble(mtcars)
```

- Different print method
    ```{r, echo = TRUE, eval = FALSE}
    print(mtcars)
    print(mtcars_tibble)
    ```

- More consistent subsetting behaviour
    ```{r, echo = TRUE, eval = FALSE}
mtcars[ ,1:2] # Return a data.frame
mtcars[ ,1]   # Returns a vector 
mtcars_tibble[ ,1:2] # Returns a tibble
mtcars_tibble[ ,1]   # Returns a tibble
    ```

---
### Tibble vs. data.frame
- Lazy and sequential evaluation 
```{r, echo = TRUE, eval = FALSE}
data.frame(x = 1:3, y = x^2) # not working
tibble(x = 1:3, y = x^2)
```

- Does not change input types
```{r, echo = TRUE, results='hold'}
text <- letters[1:3]
class(text)
df   <- data.frame(text) # stringsAsFactors = TRUE is the default 
class(df$text)
tib  <- tibble(text)
class(tib$text)
```

- For more see `vignette("tibble")`.

---
class: top, left

### dplyr
`dplyr` is the tidyverse package for data manipulations.
First we look at functions that work on a single table. 
 
- `filter()` to select rows based on their values.
    ```{r, echo = TRUE, eval = FALSE}
filter(mtcars_tibble, hp >= 100 & mpg >= 20)
    ```

- `slice()` to select rows by position. 
    ```{r, eval = FALSE, echo = TRUE}
slice(mtcars_tibble, 10:15)
    ```
- `select()` and `rename()` to select variables based on their names.
    ```{r, echo = TRUE, eval = FALSE}
select(mtcars_tibble, cyl, hp)
    ```

---
class: top, left
### dplyr

- `arrange()` to reorder rows.
    ```{r, echo = TRUE, eval = FALSE}
arrange(mtcars_tibble, cyl)
arrange(mtcars_tibble, desc(cyl))
    ```

- `mutate()` and `transmute()` to add new variables that are functions of existing variables. 
    ```{r, echo = TRUE, eval = FALSE}
    mutate(mtcars_tibble, gpm = 1/mpg)
    transmute(mtcars_tibble, gpm = 1/mpg) 
    ```
- `summarise()` to condense multiple values to a single value.
    ```{r, echo = TRUE, eval = FALSE}
    summarise(mtcars_tibble, mean_hp = mean(hp), max_mpg = max(mpg))
    ```

---
class: top, left
### dplyr
- `sample_n()` and `sample_frac()` to take random samples.
    ```{r, echo = TRUE, eval = FALSE}
    sample_n(mtcars_tibble, 10)
    sample_frac(mtcars_tibble, 0.1)
    ```

---
class: top, left
### Helper functions for select
- Select columns whose name contains a character string.
  ```{r, echo=TRUE, eval = FALSE}
select(iris, contains("."))
  ```

- Select columns whose name ends with a character string.
  ```{r, echo=TRUE, eval = FALSE}
select(iris, ends_with("Length"))
  ```

- Select every column.
  ```{r, echo=TRUE, eval = FALSE}
select(iris, everything())
  ```

- Select columns whose name matches a regular expression.
  ```{r, echo=TRUE, eval = FALSE}
select(iris, matches(".t."))
  ```

- Select columns named x1, x2, x3, x4, x5.
  ```{r, echo=TRUE, eval = FALSE}
select(iris, num_range("x", 1:5))
  ```

---
class: top, left
### Helper functions for select
- Select columns whose names are in a group of names.
```{r, echo=TRUE, eval = FALSE}
select(iris, one_of(c("Species", "Genus")))
```

- Select columns whose name starts with a character string.
```{r, echo=TRUE, eval = FALSE}
select(iris, starts_with("Sepal"))
```

- Select all columns between Sepal.Length and Petal.Width (inclusive).

```{r, echo=TRUE, eval = FALSE}
select(iris, Sepal.Length:Petal.Width)
```


- Select all columns except Species. 
```{r, echo=TRUE, eval = FALSE}
select(iris, -Species)
```


---
class: top, left
### dplyr &mdash; grouping

To exploit the full potential of `summarise()` we need to pair it with `group_by()`.

```{r, echo = TRUE, results='markup'}
by_cyl <- group_by(mtcars_tibble, cyl)
print(summarise(by_cyl, mean(mpg)))
```

---
class: top, left
### dplyr &mdash; Useful summary functions

`summary()` can be used with 

- base R functions such as `mean()`, `sd()`, `max()`
- dplyr specific functions for
  - position `first()`, `nth()`, `last()`
  - counts `n()`, `n_disticnt()`


---
class: top, left
### dplyr &mdash; Advanced subjects 



```{r}

mtcars %>%
  group_by(cyl) %>% 
  group_map(~ lm(mpg  ~ hp, data = . ), keep = TRUE)
  
```


---
class: top, left
### The Pipe

Usually we combine multiple operations together, e.g. first we filter, than we mutate, group and finally summarise. 
To do this we could save an intermidiate result after each step like this:

```{r, echo = TRUE}
filtered   <- filter(mtcars_tibble, cyl <= 8)
mutated    <- mutate(filtered, gpm = 1/mpg)
grouped    <- group_by(mutated, gear)
summarized <- summarise(grouped, count = n(), 
                        mean_hp = mean(hp),
                        mean_gpm = mean(gpm)) 
```

This code has the disadvantage that we need to save intermidiate results that we do not care about. 
---
class: top, left
### The Pipe

We could nest all those functions to get rid of the intermidiate result.

```{r, echo = TRUE}
summarise(group_by(mutate(filter(mtcars_tibble, cyl <= 8), gpm = 1/mpg)), 
          count = n(), 
          mean_hp = mean(hp),
          mean_gpm = mean(gpm))
```

However, readability gets worse and debugging will become much harder. 
---
class: top, left
### The Pipe

That is where the pipe operator `%>%` from the `magrittr` comes in handy.
The value on the left side of the operator becomes the input to the function on the right side. 

```{r, echo = TRUE}
mtcars_tibble %>% 
  mutate(gpm = 1/mpg) %>%
  group_by(gear) %>% 
  summarise(count = n(), 
            mean_hp = mean(hp),
            mean_gpm = mean(gpm)) 
  
```

The pipe operater is not limited to `dplyr` or the `tidyverse`

```{r, echo = TRUE, eval = FALSE}
1:6 %>% mean
```

---
class: top, left

## Problems

Use dplyr on the Boston crime data to:

1. Find out in which district the most incident where reported. 
2. Create an ordered list of the top ten districts according to the number of drug violations. Start with the district with most drug violations. 
3. What is the most dangerous hour of the week?
4. Calculate for each district the proportion of motor vehicle accidents on all reported incidents. 
5. Sort the data set chronological by year and month. Then take the first 10.000 observations and compute the proportion of incidents where a 
shooting was involved for each district. Now take a random sample of size 10.000. Is there a noteworthy difference?

```{r, eval = FALSE, cache=TRUE}
library(data.table)
library(tidyverse)
crime <- fread("https://data.boston.gov/dataset/6220d948-eae2-4e4b-8723-2dc8e67722a3/resource/12cb3883-56f5-47de-afa5-3b1cf61b257b/download/tmppj4rb047.csv")
crime %>% group_by(DISTRICT) %>% summarise(N = n()) %>% arrange(desc(N)) 
crime %>% filter( OFFENSE_CODE_GROUP == "Drug Violation") %>% group_by(OFFENSE_CODE_GROUP, DISTRICT) %>% summarise(N = n()) %>% arrange(desc(N)) 


d1  <- crime %>% arrange(YEAR) %>% slice(1:10000) %>% group_by(DISTRICT, SHOOTING) %>% summarise(N = n()) 
d2  <- crime %>% arrange(YEAR) %>% sample_n(10000) %>% group_by(DISTRICT) %>% summarise(N = n()) 
plot(x = factor(d1$DISTRICT), d1$N)
points(x = factor(d2$DISTRICT), d2$N)
```

```{r, eval = FALSE}
plot(table(crime$DISTRICT[1:10000])/sum(table(crime$DISTRICT[1:10000])))
points(table(crime$DISTRICT)/sum(table(crime$DISTRICT)), col = alpha("red", 0.4), lty = 3, lwd = 5)
```

---
class: top, left
### dplyr for 2 tables

```{r, echo = TRUE, results='markup'}
band_members   
band_instruments
```
---
class: top, left
### Left Join

A left join keeps all observations of the left table
```{r, echo = TRUE, results='markup'}
band_members %>% left_join(band_instruments, by = "name")
```
---
class: top, left
### Inner Join

An inner join keeps only observations if there are matches in both tables
```{r, echo = TRUE, results='markup'}
band_members %>% inner_join(band_instruments, by = "name")
```
---
class: top, left
### Full Join

A full (outer) join keeps all observations
```{r, echo = TRUE, results='markup'}
band_members %>% inner_join(band_instruments, by = "name")
```
---
class: top, left
### Semi Join

A semi join keeps all observations of the left table where there are matching values in the right table.
It keeps only tables from the left. 
```{r, echo = TRUE, results='markup'}
band_members %>% semi_join(band_instruments, by = "name")
```
---
class: top, left
### Anti Join

```{r, echo = TRUE, results='markup'}
band_members %>% anti_join(band_instruments, by = "name")
```

---
class: top, left
### Reshaping Data with tidy R

